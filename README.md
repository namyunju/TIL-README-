# TIL-README-
TIL (add a README file)
---
<details><summary>SSAFY 생활</summary>

9~11 라이브 강의
11~12 개인 복습(학습 내용 나의 언어로 정리)
12~13 함께 복습
점심
14~ 복습 및 온라인 실습 git.project 

온라인 실습
문제 들어가서 my gitlab 하고 주소 복사. 내 파일 bash 열어서 git clone 컨트롤 인서트 해서 로컬에 가져옴. 
코드 작성하고 저장. 커밋 add -m 한 후에 push. 온라인 실습실 제출까지 꼭꼭


시험은 온라인 교재에서 많이 출제됨 최소 3회독 이상

</details>


<details><summary>개발 첫 걸음_ 학습 안내</summary>

# AI 시대 공부
처음 프로그래밍 배울 때 완벽을 추구하면 길을 잃기 쉽다. 
제일 중요한 것은 ``문제 해결 능력``
Ai 시대 빠른 속도 새로운 기술. 

기초 개념 정확히 잡으면서 계속해서 실습과 프로젝트로 코딩 감각을 익히는 과정을 반복해 나가야 함!!

과거처럼 모든 문법 외우고 코드를 빨리 짜는 능력? 상당 부분 AI가 대신해줄 수 있음. 

`AI라는 강력한 도구를 지휘하는 문제 해결 전문가`

경쟁력은 무엇을 만들고 싶은가? 본질적인 질문 던지는 능력.

AI에게 정확한 요구사항 전달, 결과물을 비판적으로 검증하는 능력.

이는 실습과 프로젝트를 통해 아이디어를 실현하는 과정에서 단련됨.

**코드를 통해 아이디어를 실현하고, 실용적인 결과물을 만드는 과정 을 즐기고 습관화 할 것**
AI와 협업하는 습관을 기르며 최선을 다한다면, 꾸준히 학습하고 경험을 쌓는다면, 대체 불가능한 개발자로 성장할 것.




# 학습 방법
**문제해결의 큰 그림을 그리고 핵심역량을 기르는 데 집중하자.**

어려운 개념은 개념만 이해, 인지하고 이후 심화적인 것은 필요 시 전문 도구를 사용하면 됨.

기초단계에서 메모리, 성능 최적화 얽매이지 말고 개발 경험을 쌓자.
작은 기능을 직접 완성해보는 실질적인 개발 경험이 쌓이면 성능에 대한 감각은 자연스럽게 따라옴.

AI 이용.
의도를 파악해 변수명을 다듬고 작동 이유에 대한 주석을 달며 읽기 쉬운 코드를 만들기.

디버깅 역량
코드가 원하는 대로 동작 않는 것이 개발의 진짜 시작.

AI에게 에러와 코드 보여주고 왜 발생했는지, 어떻게 해결하는지 물어보기. 구글링과 공식 문서 읽기
항상 비판적으로 검토하고 테스트하며 더 나은 방법을 생각하기.

무엇을 모르는지 파악하고 **AI에게 명확하게 질문하여 답을 얻어내는 능력**

결국엔 뭐다? 어떤 문제를 해결하고 무엇을 만들어낼 수 있는가.
각종 언어들은 이를 위한 도구.


</details>


<details><summary>2025/07/16</summary>

배운 내용:
CLI 기초문법과  martdown, git 사용법

CLI: 명령어로 사용자와 컴퓨터가 상호작용 하는 방식 command line interface

기초문법

. 현재 디렉토리
.. 상위 디렉토리
touch, mkdir, ls, cd, start, rm, pwd


CLI에서 가장 중요한 것! 경로

루트 디렉토리 / 
홈 디렉토리 ~


Markdown: 일반 텍스트로 문서를 작성하는 방법! 텍스트와 코드를 작성해 문서화.

마크다운의 여러가지 기능!

# 개발자로 성장하기
이런 거 
- 또 이런 거
**이런 것도** 되고
*이런 것* 도 되고 
---
이것도! 신기하죠?

1. 순서가
   1. 있는
        1. 리스트?

```python
print('hello')
```
이런 것도 `를 이용하여 표현 가능.쩌거 3개로 묶어주기

[이런 것도](ㅋ)
누르면 안됨
![이미지도](ㅋ) 안되긴 해
~~취소선~~
물결로 만든 취소선!

더 알고 싶은 건 마크다운 가이드로!


<details><summary>git 이용법</summary>


Git이란? 분산 버전관리 시스템

버전관리란 변화를 기록하고 추적하는 것.

git은 파일의 변경 이력을 모두 기록한다. 누가 언제 무엇을 변경했는지 알 수 있고 이전 버전으로 돌아갈 수도 있고 실수로 잘못 변경했을 때 되돌리기도 쉽다! 뭐 게임 잘못 업데이트해서 버그 생기면 과거 특정 시점의 상태를 복원할 수가 있다!!!

분산형 시스템이라 중앙 서버 없이 작업이 가능하다. 오프라인상태에서도!!
협업도!
배포와 백업에도 좋다.

---

git의 3영역

`working directory, staging area, repository`

작업디렉토리는 git 리포지토리 파일이 실제로 저장된 위치로 파일을 편집, 추가, 삭제하는 작업을 진행함. git은 이 파일들이 변경되었는지 여부를 **추적**하지만!!! 이 시점에서 Git이 그 변경을 **관리**하지는 않는다. 

변경 사항을 Git에 반영하기 위해서는?? Staging area 즉 스테이징 영역으로 이동시켜야 한다. 그것은 git add 파일명 또는 . 을 통해. 그러니까 git add는 git아 변경 사항 추가해줘~~ 하는 거임

Staging 영역은 Git 파일이 다음 커밋을 준비하는 곳! commit은 버전이라고 생각하면 됨. 스테이징 영역에 파일을 add 하면 git은 해당 파일을 추적하고 그 상태를 커밋할 준비가 된 상태로 만든다. 스테이징 영역에 추가된 파일은 커밋될 때만 실제로 버전관리가 이루어짐.

git status로 파일들의 위치 알 수 있음. 스테이징 영역에 있구나!

Repository 리포지토리 바로바로 git이 파일의 버전 이력을 관리하는 곳!!! 로컬 리포지토리는 작업 중인 프로젝트의 모든 버전과 변경 사항을 기록. git commit 명령 사용하여 파일을 스테이징 영역에서 로컬 리포지토리로 커밋하면 !! git이 변경 사항을 기록하고 새로운 버전으로 저장한다. 레포지토리에는 커밋 내역과 브랜치 정보가 포함되며 모든 변경 사항은 이곳에서 관리됨.
git commit -m "커밋 내역" 이렇게 치면 git은 변경 사항을 로컬 리포지토리에 저장하고 버전 히스토리에 기록한다. git log로 확인


예시 워크플로우

작업 디렉토리에서 파일을 수정한다. >> git add 파일명 으로 변경사항을 스테이징 영역에 추가하고 >> git commit -m "커밋명" 으로 레포지토리에 커밋하고! >> 리포지토리에 변경 사항을 원격 서버로 푸시하려면 git push origin main !! 
</details>


</details>


<details><summary>2025/07/17</summary>
   오늘 배운 것

Git 로컬과 원격 저장소 왔다갔다 

github 쓰는 방법

나 지금 수정하고 있잖아~~!!
저장을 안해서였다...
commit 수정 방법??

---
</details>

<details><summary> 2025/07/21 </summary>

**프로그래밍의 의미와 Python 소개 및 Data type 특징**

## 프로그래밍
프로그램: 어떤 문제를 해결하기 위한 명령어 집합 
프로그래밍의 핵심은 새 연산을 정의하고 조합해 유용한 작업을 수행하는 것!


파이썬?! 타언어에 비해 쉽고 간결한 문법
풍부한 커뮤니티와 광범위한 응용 분야(웹 개발, 데이터분석, 인공지능 등)


왜 ai와 머신러닝 개발에 파이썬을 쓸까?
여러 라이브러리 도구들이 모두 파이썬으로 제공됨.(왜? 그냥 첨 만든 사람이 파이썬으로 했나?)

파이썬 인터프리터가 사용자의 명령을 기계어로 바꿔줌

파이썬 인터프리터

1. 인간이 파이썬 프로그램 작성
2. 파이썬 인터프리터가 코드를 한 줄씩 읽고 문법 오류 확인. 없으면 바이트 코드(운영 체제가 이해하는 언어)로 변환하고 실행

사용법 2가지 
- shell 프로그램으로 한 번에 한 명령어 입력하여 실행
터미널에서 python -i 하면 파이썬 인터프리터 환경이 실행됨
근데 이렇게 잘 안 함.
>>>

- 확장자가 .py인 파일에 작성된 파이썬 프로그램 실행
파이썬 파일 vs code 터미널에 아래와 같이 입력하여 실행
$ python saple.py

  
# 표현식과 값
- 표현식: 하나의 '값'으로 평가될 수 있는 모든 코드
표현식 예시 : 3+5 / x>10 / 5*4

평가: 표현식을 계산하여 그 결과인 값을 만들어내는 과정

- 값: 표현식이 평가된 결과. 더이상 계산되거나 평가될 수 없는 프로그램의 가장 기본적 데이터
값 예시 : 8, True, "안녕하세요"

주의: 모든 값은 가장 단순한 형태의 표현식. 모든 표현식이 값은 아님.
3+5는 표현식. 자체로는 값이 아니고 평가를 거쳐야 값 8이 됨.

표현식이 평가를 거치면 값
값이 평가를 거치면 값

값이 표현식에 포함됨. 값 < 표현식


# 변수와 메모리

변수: 값을 재사용하기 위해 그 값에 붙여주는 고유 이름(값에 붙여주는 거지 표현식에 붙이는 게 아님 a = 3+5 라면, a에 8이라는 값을 할당한거지 3+5라는 표현식을 할당한 것이 아님)

a = b+1
b=2
print(a) 에러 뜸. 순서

변수 할당: 표현식이 만들어 낸 값에 이름을 붙이는 과정(연결)

할당 연산자 = : 오른쪽 표현식의 평가 결과 값을 왼쪽 변수에 저장

할당문: degrees = 36.5

변수명 규칙: 알파벳, _, 숫자로 구성. 숫자로 시작 불가. 대소문자 구분. 

파이썬의 내부예약어로는 변수 이용 불가능. True False None and as assert async 


- 변수, 값, 메모리

   우리가 변수 만들면 (a = 3) 그 '값'이 메모리 어딘가에 저장.
  변수는 그 메모리 위치 가리키는 이름표 역할. 변수는 메모리 주소 가지지 않음.
  변수는 객체를 가리키는 이름!!
  변수의 메모리 주소가 아니라 값의 메모리 주소임

그래서 여러 변수에 같은 값을 할당하는 경우 그 변수들이 가리키는 객체는 동일하고 메모리 주소도 동일함. 변수에 다른 값을 재할당하면 다른 값을 가리키게 되므로 메모리 주소도 바뀜

  메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재.(메모리주소: 컴퓨터가 특정 데이터값 정확히 찾기 위해 사용하는 기계적 숫자 주소)  

**객체**
파이썬의 모든 데이터가 객체
숫자 문자열 리스트 함수 모두 객체

객체는 3가지 정보를 가짐. **고유 ID(메모리주소) Type(타입) Value(값)**
값 타입 주소 3 개 정보를 묶은 것을 객체 object라 부름.
id(a) type(a) 


ex) a = 3 하면 3이라는 객체(메모리 주소, 타입: 정수, 값:3) 가 메모리에 만들어짐. 
a는 그 객체를 가리킴. b = a 라 하면 b도 같은 객체 3을 가리키게 됨.

그래서 a, b 메모리 주소 같아짐. 하나를 바꾸면 둘 다 같이 바뀜

<img width="321" height="387" alt="image" src="https://github.com/user-attachments/assets/972a18c6-a3a0-483c-8dc7-fa5cb6073c4d" />

<img width="357" height="399" alt="image" src="https://github.com/user-attachments/assets/de43150d-d438-4709-a4c1-e7fcab14fb6a" />

변수는 특정 객체를 가리키는 이름표. 
변수는 메모리주소를 가지지 않는다.참조할 뿐
변수는 한 마디로 '객체를 가리키는 이름'


할당문 variable = expression

- 할당문 동작 순서
오른쪽 표현식 평가. 계산하여 하나의 결과값(객체)를 만듦. > 왼쪽 변수명 확인. 새로운 이름표 만들거니 기존 거 이용 > 변수명과 결과값 연결!!(참조). 변수가 이전에 다른 객체 가리키고 있었다면 그 연결 끊어지고 새로운 객체와의 연결만 남음 (재할당)



|용어|핵심 정의|비유(주소록)|
|---------|------|------|
|객체 object|데이터(값 타입 행동)의 실체|'김철수'라는 실제 사람|
|메모리 주소|객체가 저장된 고유한 위치|김철수의 실제 집 주소|
|변수 variable|객체를 가리키는 이름표|주소록에 저장된 '내친구 김철수'라는 이름|



# 데이터 타입

아까 객체는 고유id 메모리 주소, 타입, 값 의 묶음이라 했죠?
데이터 타입은 값의 종류와 적용 가능한 행동의 묶음입니다.

타입: 변수나 값이 가질 수 있는 데이터의 종류

타입의 구성요소: 값(피연산자)과 값에 적용 가능한 연산자. 이 두 가지로 구분할 수 있음. 

값은 숫자일수도 글자일 수도 소수일 수도 있음

중요한 이유: 값의 종류와 그 값으로 할 수 있는 연산을 결정하기 때문. 즉, 타입마다 가능한 기능과 연산이 다름.

data type: 값의 종류와 그 값으로 할 수 있는 동작(연산)을 결정하는 속성


데이터 타입의 5분류: numeric types / text sequence(str) / sequence type(list tuple range) / non sequece type ( set, dict) / 기타 (boolean none functions)

정수 int 
실수 float 소수점까지. 
지수표현법 1,230,000,000은 1.23 * 10^9 인데 이걸 1.23e9라고 표현함.
0.00314는 3.14 * 10^-3 이라서 3.14e-3이라 씀 e E 상관없음.
<img width="437" height="364" alt="image" src="https://github.com/user-attachments/assets/a51cdb69-6f81-463e-8f8f-84b1f35a7757" />


숫자형 타입의 행동은 산술 연산!
<img width="312" height="120" alt="image" src="https://github.com/user-attachments/assets/c580aaba-8465-4a9f-b133-ca8b4bcb1d9b" />
<img width="310" height="108" alt="image" src="https://github.com/user-attachments/assets/fe3c42c4-0f3e-4c7e-acde-d0b43f4fc1ea" />

연산자 우선순위는 동일 ** 다음 -(음수부호) . () 사용 가능.

    -2**4 = -16 = -(2**4)


시퀀스 타입: 여러 데이터가 정해진 `순서`대로 일렬로 `나열`하여 저장하는 자료형 
대표 시퀀스 타입: str, list, tuple, range

순서가 있으므로 인덱스가 존재. 0번부터. 인덱스를 통해 데이터에 바로 접근 가능 

index: 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호 (0번부터)

시퀀스타입 여러가지인데 공통 특징 5가지있음.
순서대로 저장(정렬된 것은 아님)/인덱싱(값마다 고유 번호 있어서 특정 위치 값 선택 수정 가능)/슬라이싱(원하는 부분 값만 잘라서 사용)/길이(값의 개수 len() 함수 )/반복iteration(반복문으로 각 값 하나씩 순서대로 꺼내서 사용 가능)

len 은 전체 길이 (개수)알려줌. 
인덱스는 0부터 len-1 까지. 길이 넘어서는 인덱스 입력 시 에러뜸



시퀀스 타입 중 문자열str
```python

my_data = 'Hello'

my_data[1] = 'e'
my_data[1:4] = 'ell'


```
len은 5임. 인덱스는 0부터 4까지 존재
[1:4] 하면 1번부터 3번까지 해당됨. 항상 뒤에 오는 인덱스는 제외하고 그 이전까지만.

문자열 str : 문자들 `순서` 있고 `변경 불가능`한 시퀀스 자료형

`escape sequence`
\ 역슬래시와 문자 조합 특별한 기능
\n 줄바꿈 \t 탭 (띄우기) \\ 백슬래시 하나 \' 작은 따옴표 \" 큰 따옴표 \b는 앞에 지움

여러 줄 작성 시 ''' 또는 """ 이용 ('하나만 쓰면 한 줄만 인식해서 에러뜸)



# f-string 아주 중요!

문자열 내에 변수나 표현식의 결과를 쉽게 삽입하는 방법.
문자열 시작 전에 f 붙이고 삽입할 부분을 {} 로 감싸줌. 

```python
name= '홍길동'
age=25

greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'

```
안녕하세요, 제 이름은 홍길동이고 나이는 25살입니다.


<img width="299" height="173" alt="image" src="https://github.com/user-attachments/assets/4fc74cb7-bb0e-4208-b27a-188ade47daa6" />

f-string 다양한 기능 있음. 심화 사용법 알아보기





index: 시퀀스 자료형 각 값의 위치를 식별하기 위해 부여된 고유 번호. 0부터 시작 왜? 거리 개념임. 시작점으로부터 떨어진 거리. 
음수 인덱스 지원. -1은 맨 마지막 값. 

slicing: 시퀀스 일부분 잘라내어 `새로운 시퀀스 생성`
슬라이싱 사용법 대괄호 [] 안에 시작 위치, 끝 위치, 간격 을 콜론:으로 구분하여 지정
my_sequence[start:stop:step]
<img width="392" height="327" alt="image" src="https://github.com/user-attachments/assets/e0450cc0-7328-491c-8bce-1073db4ee270" />

start 시작인덱스(포함)
stop 끝 인덱스(포함x)
step 건너뛰는 간격 
상황따라 생략 가능


my_str[2:4] 하면 2,3 자리 나오고 4는 포함 안됨.

왜 끝에 값은 빠질까???
시작 값은 0 n번 반복 시 실제로 마지막 시행은 n-1번째가 됨. 즉, 3번 반복 시 0,1,2 가 시행됨. 그래서 마지막 수 앞에서 멈춤.
너무 헷갈린다면 문자열 사이를  index로 생각.


여러가지 해보니까 my_str[7]처럼 아예 벗어난 인덱스 주면 error 뜨는데 [7:9] 나 [9:7] 같은 거 넣으면 error 안 뜨고 그냥 값이 안 나옴. [::-1] 은 역순


`문자열의 불변성`

문자열은 순서가 있고 변경이 불가능한 시퀀스형 자료!!!
(리스트는 변경 가능)
my_str[1] = 'a' 와 같이 할당하려하면 error
type error 'str' object does not support item assignment 

변경은 불가능. 재할당하거나 새로운 문자열을 생성하는 수밖에


<details><summary>참고</summary>

진법 표현 접두사 prefix
0b 0o 0x

2진수 print(0b10) >>> 2 (2진수 10은 10진수로 2)
8진수 print(0o30) >>> 24 (8진수 30은 24)
16진수 print(0x10) >>> 16 (16진수 10은 16)

<img width="332" height="384" alt="image" src="https://github.com/user-attachments/assets/6f3a3543-9a98-486e-bfb8-43e7830d5d76" />


실수의 함정, 부동소수점 오차

result = 0.1 + 0.2 

print(result == 0.3) False

print(result) 0.300000000004

왜?
컴퓨터의 실수 처리 방식.
부동소수점(반올림)오차


컴퓨터는 2진법을 사용. 무한 소수의 발생과 근삿값 저장.10진수 소수 중 일부 2진수로 바꾸면 무한 소수 됨. 

예를 들어 0.1 을 2진수로 바꾸면 무한 소수가 됨. 0.0001100110011 ...

메모리 유한하므로 근삿값으로 잘라서 저장함. 근사치로 인해 오차 발생.


> 해결책

decimal 모듈 사용해 부동소수점 연산의 정확성을 보장 
실수를 2진수로 변환하지 않고 10진수 자체로 정확하게 연산할 수 있게 해줌.
소수 계산할 때 조심하기

a = Decial('3.2')


# 표현식과 문장

표현식은 아까 했죠? 
평가를 거쳐 값이 되는 것을 표현식이라고 한다고. 3+5 True 등

표현식이 아닌 거는 뭐가 있냐? 바로 그게 문장! 

표현식이 값을 만들어내는 코드조각, 문장은 동작을 수행하는 코드 조각

print(10) 은 값을 반환하는 게 아니라 출력하는 동작을 함. 따라서 문장. (print는 반환값이 None)

max(2,3) 은 값을 반환하므로 표현식

할당문 조건문 반복문 등!! 문장은 statement 특정 동작을 지시하는 실행 가능 코드 최소단위. 문장은 완결된 하나의 명령 

예시: x = 100 / def my_function() / pass 등


구분: 코드 실행 시 하나의 값이 남는다면 표현식, 안 남는다면 문장. 
10+20 : 표현식
name = '홍길동' : 문장(변수에 지시했을 뿐 값이 남지 않음)

관계도 : 문장 == 요리법       표현식 == 재료

표현식 사용해서 문장 만들 수 있고 표현식 하나가 문장이 되기도?

total_price = 5000 + 1000  : 할당문 (문장)

뜯어보면

5000 + 1000 : 표현식 (값 6500을 만들어냄)

total_price = : 표현식이 만든 값을 변수에 할당하라고 지시하는 문장

대부분 문장은 표현식을 포함하여 동작

Style Guide 코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들
대표적으로 PEP 8

직관적인 이름, 공백 스페이스 4칸 or Tab
한 줄 길이 79자, 길면 줄 바꿈 
문자와 밑줄로 작성, 함수 정의 클래스 정의 등 블록 사이에는 빈 줄을 추가

age=10 말고 age = 10

주석:
샾 사용 여러줄은 """ 또는 묶어서 한 방에 컨트롤 슬래쉬

복잡한 코드 python tutor 코드 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구



터미널에 ls 쳐서 내가 실행하고 싶은 파이썬 파일이 존재하는지 확인하고 실행하기
python 파일이름 하면 내가 원하는 파이썬 파일 실행됨.

double에 2*10 값을 저장한 것,
값이 저장되는 것이지 표현식을 저장하는 것이 아님.
좀 중요함 헷갈리는 부분. double에 20이 저장되는 것이지 2*num 이 저장되는 것이 아니다잉


16진수
0부터 9까지 이용 후 a부터 f까지 감 우왕~~굉장히 10진법적인 사고



</details>
</details>


<details><summary>2025/7/22</summary>

**여러 데이터 타입과 연산자**

다양한 데이터 구조와 연산자를 활용하여 장바구니를 직접 만들고 관리할 수 있다.


복습: 시퀀스 자료형 시퀀스의 특징 5가지
시퀀스 자료형이란, 여러 개의 값을 `순서`대로 저장하고 각 요소를 `인덱스`를 통해 접근할 수 있는 자료형.
str, list, tuple이 있음. (dict와 set은 시퀀스 자료형 아님. 순서 없고 인덱스로 접근 불가)

특징 5가지: 순서 있음, 인덱싱 가능 a[2], 슬라이싱 가능 a[1:3], 반복 가능, 길이 확인 가능

(추가: 문자열뿐만 아니라 정수형, 실수형 등도 불변. a = 10 에서 0을 1로 인덱싱해서 바꾸는 것 불가능. 재할당하는 수밖에)


# 리스트

- 여러 개의 값을 `순서`대로 저장하는,`변경 가능한``시퀀스 자료형` mutable
- 시퀀스이므로 인덱싱 슬라이싱 길이 모두 가능
- 대괄호[] 안에 값들을 쉼표 , 로 구분
- 숫자 문자열 다른 리스트까지 모든 종류 데이터 담을 수 있다.
- 값을 추가 수정 삭제 등 자유롭게 변경 가능 
- 중첩nested 리스트 : 다른 리스트를 값으로 가진 리스트 my_list[4][2][3]

중첩: 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태
(재귀함수같은)
 
 
가변성: 생성된 후 그 내용을 변경할 수 있는 성질.
변경: 수정 추가 삭제 
문자열의 불변성과 정반대되는 중요한 특징.

1. 인덱싱으로 값 수정하기
2. 슬라이싱으로 여러 값 한번에 바꾸기
my_list = [1,2,3,4,5]
my_list[2:4] = ['three', 'four']
print(my_list) [1,2,'three,'four',5]
list는 가장 많이 활용하게 될 data type 중 하나

[2:4]로 하면 2,3  요소 없어지고 그 자리에 들어가는 새로운 요소 개수 제한 없음.

<img width="496" height="246" alt="image" src="https://github.com/user-attachments/assets/73300151-675f-498f-a1b8-4dd065878f3c" />
<img width="639" height="398" alt="image" src="https://github.com/user-attachments/assets/a40456bb-cc2e-4501-b7df-0759aff43c8d" />
<img width="394" height="215" alt="image" src="https://github.com/user-attachments/assets/063b9fad-b964-4ffb-af10-c07969e5fca3" />

슬라이싱 할당에서 오른쪽에는 반드시 반복가능한 iterable 객체가 와야 함. 그래서 정수 불가능.

하나씩 쪼개서 할당함. 

반복 불가능: int float boolean Nonetype complex


# 튜플

- 여러 개의 값을 `순서`대로 저장, `변경 불가능`한 시퀀스 자료형
- 소괄호() 이용, 쉼표 , 로 구분
- 리스트처럼 모든 종류 데이터 담을 수 있음
- 리스트와 유사하나, 한 번 만들어지면 수정 불가능. `불변성`
- 시퀀스이기 때문에 순서, 인덱싱, 슬라이싱, 길이 확인, 반복 이용 가능   
  특징
  - 요소가 하나일 때 쉼표 , 이용 my_tuple = (1, ) trailing comma 후행쉼표라고 함.
  - 물론 빈 튜플도 가능 my_tuple = ()
  - 소괄호 없이 만들 수 있음. my_tuple = 1, 'hello', 3.14
<img width="401" height="123" alt="image" src="https://github.com/user-attachments/assets/5c732366-7e6b-45c3-90b7-6a953aedd84a" />
후행 쉼표 없으면 int가 되네<img width="420" height="238" alt="image" src="https://github.com/user-attachments/assets/24a4f05f-b769-40cc-8399-9e423bb49680" />


튜플은 언제 쓰냐?
튜플이 불변 자료형인 이유는?
튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용.
다중 할당, 값 교환, 함수 다중 반환 등
개발자가 직접적으로 사용하기보다는 내부적으로 처리될 때 사용됨

튜플은 데이터의 안정성과 무결성을 보장하기 때문에 리스트와 구별됨. 내부동작에서 사용
실제 문제 풀 때 쓰는 경우 거의 없음.

<img width="508" height="284" alt="image" src="https://github.com/user-attachments/assets/213da17c-9bd7-482c-96cc-809bd42c76bc" />




```python
#다중할당
x, y = 10, 20
#실제 내부 동작
(x, y) = (10, 20)

#값 교환
x, y = 1, 2
x, y = y, x

#실제 내부 동작
temp = (y, x) # 튜플 생성
x, y = temp # 튜플 풀어냄
print(x, y) # 2 1

```


# range

`연속된 정수 시퀀스` `생성`하는 `변경 불가능`한 자료형

(변경 가능한 자료형은 아직 리스트밖에 없노! 문자열, 튜플, range 다 불변)
- range는 주로 반복문에서 사용. 특정 횟수만큼 딱 반복
- 시작, 끝, 간격 규칙만 기억. 메모리 효율적
- range() 는 1,2,3 개까지의 매개변수를 가질 수 있음.
  - range(stop)
  - range(start, stop)
  - range(start, stop, step)

```python
# 매개변수 하나일 때. stop으로 인식. start는 0, step은 1이 기본값으로 설정
my_range_1 = range(5)

print(my_range_1) # range(0, 5)

print(list(my_range_1)) # [0, 1, 2, 3, 4] 리스트로 형 변

# 매개변수 두 개
my_range_2 = range(1,10)

# 매개변수 세 개
my_range_3 = range(5, 0, -1)

print(list(my_range_3)) # [5, 4, 3, 2, 1]


```
- range에서 모든 숫자 메모리 저장하는 게 아니라 시작, 끝, 간격이라는 규칙만 기억하여 메모리 효율적
- range는 list로 `형 변환` 시 내부 값을 확인 가능. 실제 사용할 때는 형 변환하지 않고 반복문에 사용

```python
for i in range(1,10,2):
   print(i)   # 1, 3, 5, 7, 9
```

step 규칙
step은 시퀀스의 간격과 방향을 결정
error가 나지는 않음. step의 부호에 따라 start와 stop의 대소관계 생각.

항상 스탑 값 앞까지! stop 값은 시퀀스에 포함될 수 없음


# dict

오늘의 수업 중 젤 중요한 것 두 가지 꼽으라면 list와 dict

**딕셔너리: key와 value 쌍으로 이루어진, 순서와 중복이 없는 변경 가능한 자료형.(비시퀀스)**

순서가 없다?! >> 인덱스가 없다.
인덱스 없이 어떻게 접근해? >> key로 접근!

- 중괄호 {} 이용. 쉼표, 로 구분
- 값 1개는 키와 값이 쌍으로 이루어져있음
- my_dict = {'key': 'value'} # 한 쌍
  
- key: 값을 식별하기 위한 고유한 이름표. 중복 불가(순서가 없는 대신 고유한 키로 구분).
  변경 불가능한 자료형만 사용 가능. (str, int, float, tuple 가능, list, dict 불가능)
  
- value: 키에 해당하는 실제 데이터. '문자열', 12, [l, i, s, t] 모두 가능

- key로 value 찾기 가능, 역은 불가능. key는 고유하지만. value는 여러 번 나와도 됨.

- key가 두 번 이상 나온다면? 뒤에 나온 것 기준으로 하나만 나옴.

dict = {'apple': 500, 'apple': 300} 
print(dict['apple']) # 300


순서가 없는 자료형. 비시퀀스. key를 통해 접근

print(my_dict_1[key]) 하면 value가 나옴, 존재하지 않는 key 쓰면 error

딕셔너리 언제 이용하냐?

데이터에 순서 필요 없고 데이터에 key 붙여 관리하고 싶을때 이용. 인적 정보나 캐릭터 능력치 


# set
---
`순서와 중복이 없는` `변경 가능`한 자료형. 비시퀀스(인덱싱, 슬라이싱 사용 불가. 근데 len은 사용 가능.)

두 가지 핵심: 중복 허용 X / 순서가 없음! (인덱싱 슬라이싱 불가능)

- 중괄호{} 이용, 쉼표 , 로 구분.
- 딕셔너리도 중괄호 {} 이용! >> 공집합은 {}로 표현 못함. 딕셔너리니까! set() 으로
- my_set_1 = set() 라고 표현함. my_set_2 = {1, 1, 2} #print(my_set_2) {1, 2}
- 원소 동일하면 하나만 나옴.(중복 불가) 순서 없으므로 인덱싱 불가
- 합집합 | (shift 백슬래쉬), 차집합 -, 교집합 &
- 중복 제거하고 싶을 때 사용 가능
- 잘 사용 안하긴 함. 특수 상황에서 사용


# Other types
---
None: 값이 없음을 표현하는 특별한 데이터 타입. 숫자 0이나 빈 문자열 '' 과는 다름!! 값이 존재하지 않음, 아직 정해지지 않음 이라는 상태를 나타냄.
대소문자 주의. None 이다.

Boolean: 참과 거짓 두 가지 값만 가지는 데이터 타입. 프로그램의 흐름을 제어하는 조건문에서 True와 False를 판단
주로 조건 반복문과 함께 사용됨.
비교 논리 연산의 평가 결과



# Collection
---
여러 개의 값을 하나로 묶어 관리하는 자료형들을 `통칭`하는 말
str, list, tuple, range, set, dict 데이터 타입 모두 Collection에 분류.

|컬렉션명 | 변경 가능 여부(가변성, 불변성) | 순서 존재 여부(인덱싱 가능 여부)|
|---|---|---|
|str |X|O|
|list|O|O|
|tuple|X|O|
|dict|O|X|
|set|O|X|
|range|X|O|


# 형변환
---
한 데이터 타입을 다른 데이터 타입으로 변환하는 과정.


암시적 형변환과 명시적 형변환

암시적 형변환: 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것

데이터 손실 막으려고 더 정밀한 타입으로. 더 안전한 쪽으로 파이썬이 자동 처리

불리언과 뉴머릭 타입에서만 가능함.
숫자형 자료 더 큰 범위로, boolean과 수

ex) print(3 + 5.0) # 8.0
   print(True + 3) # 4
   print(True + False) # 1

명시적 형변환: 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것.
서로 다른 타입의 데이터를 호환되도록 맞추는 과정.
해외에서 어댑터 끼우는 느낌. 

int("123") 결과 123
str(100) 결과 "100"
list("abc") 결과 ['a', 'b', 'c']
set([1, 2, 2]) 결과 {1,2}
<img width="373" height="160" alt="image" src="https://github.com/user-attachments/assets/0bfee477-15fe-469d-b8f8-647d2c25cfe9" />

항상 되는가?

str -> int 형식에 맞는 숫자만 가능

print(int('1')) # 1 '1' 문자열을 정수로 형 변환.

print(int('3.5')) # '3.5'는 실수형태의 문자열이므로 error 뜸.

print(float('3.5')) # 3.5 '3.5'라는 문자열을 실수로 형 변환.

print(int(1.9)) # 1 실수를 정수형으로 형 변환.

int -> str 모두 가능

print(str(2) + '등') # 2등

그 무엇도 range와 dict으로 형 변환 불가능함.


# 연산자
---
산술연산자, 복합연산자, 비교연산자, 논리연산자, 단축 평가, 멤버십연산자, 시퀀스형 연산자 그리 연산자 우선순위


복합연산자: 연산과 할당이 함께 이뤄짐.

+= -= *= /= //= %= **=  알 것 같기도~  x **= 3 : x에 x의 3승을 할당해라

비교 연산자

True False 로 반환

ㅡ=, ==, !=, is, is not

is 연산자는 단순 값 비교가 아닌 객체를 비교. 메모리 주소가 같은지를 확인 식별성

is: identity operator 정체성   ==: equality operator 값

is 연산자는 싱글턴 객체 비교에 사용

프로그램 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체. 싱글턴 객체: None True False


<img width="318" height="399" alt="image" src="https://github.com/user-attachments/assets/57e6cced-8a79-4895-8597-1d1a464b88bc" />

b=a 
print(a is b) True

논리 연산자
and or not


단축 평가: 논리 연산 두 번째 피연산자 평가하지 않고 결과를 결정하는 동작

똑똑한 게으름?!: 결과가 정해졌다면 뒤에 코드까지 확인하지 않음. 이렇게 결과가 확정되는 순간 평가를 '단축'하고 넘어간다고 해서 '단축 평가' 라고 부름.

거짓으로 취급되는 값들: False, 숫자 0, 빈 문자열 "", 빈 리스트 [], None 등 
참으로 취급되는 값들: True, 1, -10, "hello", [1,2] 등 내용이 있는 값

and 연산자 하나라도 거짓이면 거짓. 쭉 가다가 처음 만나는 거짓을 바로 반환. 모두 참이면 마지막 참 반환

or 연산자 하나라도 참이면 참. 끝까지 갔는데 모두 거짓이면 맨 마지막 거짓값을 반환

단축 평가 >> 코드 실행 최적화하고 불필요한 연산 피함, 코드 흐름 제어 오류 방지 간결 코드 


멤버십 연산자: in, not in 
print('h' in word)  
왼쪽이 요소 오른쪽이 컬렉
결과값: True, False


시퀀스형 연산자: + *
+ * 가 시퀀스자료형(문자열, 리스트, 튜플)에서 결합, 반복 연산자로 쓰임.


trailing comma(후행 쉼표)
컬렉션의 마지막 요소 뒤에 붙는 쉼표
앞에 하나의 요소로 구성된 튜플에서 필수였음. tuple = (1,)
그 외에는 `선택 사항`


기본규칙
각 요소 별도 주루 작성하고 콤마 추가 닫는 괄호도 새로운 줄

딕셔너리에서 잘 사용됨. 가독성 측면에서

```python
item = [
   'item1',
   'item2',
   'item3',
]

config = {
   'host': 'localhost',
   'port': 8080,
   'debug': True,
}


```

각 요소 별도 줄에 작성. 마지막 요소 뒤에 trailing comma 추가, 닫는 괄호는 새로운 줄에 배치.
그냥 한 로 쭉 쓸 때는 trailing comma 쓰지 않음.

`문제 풀이
리스트 [1:4]면 그 앞에까지 
딕셔너리는 {'키': '값'}
역순[::-1]
set는 순서 없고, 중복 허용하지 않음
딕셔너리는 value 바꿀 수 있음.

</details>

<details><summary>추가학습</summary>

<details><summary>얕은 복사와 깊은 복사</summary>

python tutor 을 이용한 시각화

메모리 위치


backup_catalog = catalog   할당 
<img width="781" height="464" alt="image" src="https://github.com/user-attachments/assets/1c86c970-373f-43fe-9b1b-51cb4c879a18" />

그냥 원래 list를 그대로 가져옴 (복사가 아님)



backup_catalog = catalog.copy()   얕은 복사
<img width="778" height="546" alt="image" src="https://github.com/user-attachments/assets/0c7be1bd-38c5-43b8-b439-2d4cd187a46a" />

겉의 리스트 껍질만 새로 만들고 내부의 객체 리스트는 기존의 것과 같은 것을 참조함.

즉, 바깥쪽 리스트만 복사되고, 내부 리스트는 원본과 공유함. 

**>> 내부 객체를 변경하면 복사본과 원본 모두에 영향을 미친다.**

backup_catalog = deepcopy(catalog)   깊은 복사
<img width="773" height="742" alt="image" src="https://github.com/user-attachments/assets/ada8ec57-dde2-444f-a7fc-8c406b0a5eab" />

**겉의 리스트뿐만 아니라 내부에 포함된 모든 객체까지 새로 복사**

**원본과 복사본이 완전히 독립적이고, 내부 객체를 변경해도 서로 영향을 주지 않음.**

</details>


<details><summary>List</summary>

```python

list = [1] * 5
print(list)   # [1, 1, 1, 1, 1]







```



</details>


</details>







<details><summary>2025/07/23</summary>

# 함수

함수란! : 특정 작업을 수행하기 위한 `재사용` 가능한 코드 묶음. 

- 반복되는 코드를 하나로 묶어 재사용하기에 코드가 깔끔해짐.
- 복잡한 문제를 작은 단위로 나누어 해결하는 프로그래밍 사고력 기를 수 있음.

  함수 왜 씀? >> 재사용성 높아지고, 코드의 가독성과 유지보수성 향상.

예를 들어 두 수의 합. 매번 변수를 더하는 코드를 입력하기보다 sum이라는 함수를 만들어서 이용하는 게 편리

```python

# 함수 정의
def get_sum(num, num2):
   return num1 + num2

# 이후부터는 함수를 호출하여 결과 출력


```


함수 호출. 

함수 구조

```python   
def make_sum(pram1, prma2):   # parameter 1, 2가 INPUT값
   """이것은 두 수를 받아      # """ 속이 Docstirng
   두 수의 합을 반환하는 함수입니다.   # 들여쓰기 된 부분 모두 function body
   >>> make_sum(1, 2)
   3
   """
   returm pram1 + pram2      # return value OUTPUT
```

- parameter INPUT
- doctring: 함수에 대한 설명 """ """ 선택적으로 작성 가능. 협업을 위한. 
- function body: 함수 아래에 들여쓰기 되어있는 코드 블록, 함수가 실행될 때 수행되는 코드를 정의.
- return value OUTPUT: return 이후에 반환값 명시. return문은 함수의 실행을 종료, 결과를 호출 부분으로 반환함.
- 함수에 return 문이 없다면 None이 반환됨.


겁준다
첫 번째 허들이래

print() 함수는 반환 값이 없음. return이 없음.

**반환과 출력을 구분해야 함**
print() 함수는 화면에 값을 출력하기만 할 뿐, 반환(return)값이 없음.

```python

return_value = print()
print(return_value)
>>>None

```

반환값이 없는 함수를 출력해보면 None이 나옴.

반환이란 어떤 값이 있어야 함. 

합성함수 느낌?


- 매개변수parameter과 인자argument
- 매개변수: 함수를 정의할 때, 함수가 받을 값을 나타내는 변수
- 인자: 함수를 호출할 때 실제로 전달되는 값

```python
def add(x, y):   # x, y는 매개변수
~~

a = 2
b = 3

sum = add(a, b)   # a, b는 인자

```

- 인자의 종류 5가지
  위치 인자, 기본 인자 값, 키워드 인자, 임의의 인자 목록, 임의의 키워드 인자 목록
  - 위치 인자
    함수 호출 시 인자의 `위치`에 따라 전달되는 인자.
    반드시 값을 전달 해야 함. 값 안 넣으면 에러 뜸
  - 기본 인자 값
    함수 정의에서 매개변수에 기본 값을 할당.
    함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당됨.
  - 키워드 인자
    함수 호출 시 인자의 이름과 함께 값을 전달하는 인자.
    키워드 인자는 위치 인자보다 뒤에 위치해야 함. 아니면 error 뜸.
  - 임의의 인자 목록 AAL
    정해지지 않은 개수의 인자를 처리하는 인자
    함수 정의 시 매개변수 앞에 *를 붙여 사용
    여러 개의 인자를 tuple로 처리

    ```python
       def cal_sum(*args):
       print(args)   #(1,100,5000,30)
       print(type(args))   # class tuple
       cal_sum(1,100,5000,30)
   ```

   - 임의의 키워드 인자 목록
   정해지지 않은 개수의 키워드 인자를 처리하는 인자.
   함수 정의 시 매개변수 앞에 **를 붙여 사용
   여러 개의 인자를 dictionary로 묶어 처리함.

   - 함수 인자 권장 작성 순서
   위치 기본 가변 가변키워드 순서로 하여 혼란 줄임.
   절대적인 규칙 아니고 상황에 따라 유연하게


<img width="578" height="416" alt="image" src="https://github.com/user-attachments/assets/adc66a48-ea3e-4970-a751-e5fea7d2d86d" />




**재귀함수**

함수 내부에서 자기 자신을 호출하는 함수.

끝없이 호출하지 않도록 종료 시점을 명시해줘야 함.

재귀함수의 예시 - factorial
- 자기 자신을 재귀적으로 호출하여 n!을 계산
- 재귀 호출은 n이 0이 될 때까지 반복, 종료 조건 설정하여 재귀 호출 멈추게 함.
- 재귀 호출 결과 이용하여 문제를 작은 단위의 문제로 분할하고, 분할된 문제들의 결과를 조합하여 최종결과를 도출

  ```python
  def factorial(n):
     if n == 0:
        return 1   # 종료 조건을 먼저 명시
     else:
        return n * factorial(n - 1)   # 재귀 호출: n과 n-1의 팩토리얼을 곱한 결과를 반환

  ```

  - 5!의 경우 1부터 5까지의 곱인데, 5 * 4! 으로 분할하고, 또 5 * 4 * 3! 으로 분할하고 ... 언제까지? base case에 수렴할 때까지. 팩토리얼은 * 1 까지.
 
재귀함수 특징
- 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, 코드의 가독성이 높아짐.
- 한 개 이상의 base case(종료되는 상황) 존재하고, 수렴하도록 작성.
- 꼭꼭! 종료 조건 명확히 하고, 반복되는 호출이 종료 조건을 향해야 함.(수렴)
- 단점은 메모리 사용량 많고 느릴 수 있다. 종료 조건 잘못되면 스택 오버플로우 에러 발생 가능. 복잡하면 코드 가독성 저하

왜 써? 문제를 간결하고 직관적으로 표현 가능, 코드 간결하고 수학적 문제 직접적 구현 가능하다.


# 내장 함수 built-in function
---
파이썬이 기본적으로 제공하는 함수. 별도의 import 필요 없이 바로 사용 가능

[파이썬 공식 문서](https://docs.python.org/ko/3/)

자습서랑 라이브러리 레퍼런스 언어 레퍼런스 참고하면 좋다


# 함수와 scope
---
python의 범위scope

scope란?

변수나 함수가 유효한 범위. 어디에서 이것을 쓸 수 있는가! (Local Enclosing Global Built-in)

함수는 코드 내부에 local scope를 생성함. 그 외의 공간을 global scope로 구분함.

global scope(코드 어디에서나 참조가능 공간)와 local scope(함수 내부에서만 참조 가능)

global variable(global scope에 정의된 변수)과 local variable(local scope에 정의된 변수)


정의하지 않고 어디에서나 쓸 수 있는 함수 >> built-in scope  예를 들어 print()

정의하고 어디에서나 쓸 수 있는 함수 >> global scope


변수 수명주기


이름 검색 규칙

LEGB 룰

<img width="667" height="276" alt="image" src="https://github.com/user-attachments/assets/b156efef-e9b2-4ab6-ac7d-63485c763098" />


enclosed는 f함수 내에 g함수가 있는 경우 f와 g 사이의 영역 

안에서 바깥 scope 쪽으로 접근 가능, 반대로는 불가능

예를 들어, sum이라는 내장함수가 있는데 sum = 5 라고 코드를 넣어버리면 sum의 타입이 int가 되어버림

global에서 찾고 built-in 으로 가기 때문에 sum이라는 내장함수를 이용할 수 없게 됨.



```python


x = 'G'
y = 'G'

def outer_func():
   x = 'E'
   y = 'E'

   def inner_func(y):
      z = 'L'
      print(x,y,z)      # (E, P, L) 

   innter_func('P')
   print(x, y)          # (E, E)  

outer_func()
print(x, y)              #(G, G)

```
<img width="842" height="454" alt="image" src="https://github.com/user-attachments/assets/ede001ae-db63-4676-b9e5-ae680918296a" />

** 함수의 정의와 호출 시점을 잘 봐야 함. **

나의 착각: print(x, y, z) 이후에 inner_func('P')가 왔으니까 y에 P가 들어가는 건 출력된 이후 시점 아닌가?

실제로는 print(x, y, z)는 inner_func(y)의 정의에 속해있을 뿐, 실행된 것이 아님.

실행은 그 아래에 inner_func('P') 라는 호출문이 오면서 실행된 것!

따라서 E P L


# global 키워드

변수의 스코프를 전역 범위 global 로 지정하기 위해 사용

일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용함.ㅏ

num = 0   # 전역 변수
def increment():
   global num   # num을 전역 변수로 선언
   

# 함수 이름 작성 기본 규칙

- 소문자와 언더스코어_ 사용
- 동사로 시작. 함수의 동작 설명
- 약어 사용 지양. 길게, 기능 분명하게 쓰기
- 동사 + 명사 / 동사 + 형용사 + 명사 / get set _ 접두사
- calc_price가 아니라 calculate_total_price
- true False 반환시 이름 시작을 is_ 또는 has_ 


단일 책임 원칙. 

모든 객체는 하나의 명확한 목적과 책임만을 가져야 함.

함수 설계 원칙
- 명확한 목적 (한 가지 작업만 수행)
- 책임 분리 (데이터 검증 처리, 저장 등을 별도 함수로 분리, 독립적으로 동작하게 설계)
- 유지보수성 (작은 단위 함수로 나누어 관리. 코드 수정 시 영향 범위 최소화)


# 패킹과 언패킹

여러 개의 데이터를 하나의 컬렉션으로 모아 담는 과정. 

여러 개의 값을 하나의 튜플로 묶는 파이썬의 기본 동작.

한 변수에 콤마, 로 구분된 값을 넣으면 자동으로 튜플로 처리

- *를 활용한 패킹 (함수 매개변수 작성 시)
  남는 위치 인자들을 튜플로 묶기. *를 붙인 매개 변수가 남는 위치 인자들을 모두 모아 하나의 튜플로 만듦.

   args 말고 다른 매개변수 사용해도 되는데 *args 는 암묵적 합의

- **를 활용한 패킹 (함수 매개변수 작성 시)
  남는 키워드 인자들을 딕셔너리로 묶기

  **를 붙인 매개변수가 남는 키워드 인자들을 모두 모아 하나의 딕셔너리로 만듦.

<img width="841" height="38" alt="image" src="https://github.com/user-attachments/assets/757e9538-3f22-4a75-8254-6a0f577ef7ef" />

위치 인자와 end = ' ' 순서 바꿔보고 이것 저것


언패킹: 컬렉션에 담겨 있는 데이터들을 개별 요소로 펼쳐놓는 과정

*을 활용한 


# 참고
---
- 함수와 반환

파이썬 함수는 언제나! 단 하나의 값(객체)만 반환할 수 있음.

여러 값을 반환하는 경우에도 하나의 튜플로 패킹하여 반환하는 것임.


- 람다 표현식

익명 함수를 만드는 데 사용되는 표현식. 한 줄로 간단한 함수를 정의 (def같은 거 없이)
  
</details>



<details><summary>2025/07/25 관통프로젝트</summary>

총 10회의 프로젝트 과정 

10 번째는 최종 프로젝트 (총 합친 느낌?)

금융 상품 비교 앱 / 영화 추천 서비스 / 도서 정보 검색 서비스 택 1 또는 자유 주제(필수 기능은 포함되어야 함)도 가능

기술은 django와 vue로 고정. react나 다른 거 못씀

**API 이해하기**

오늘은~ 날씨 정보 가져와서 내가 원하는 정보만 출력!

날씨 데이터가 필요! but 직접 모아?! 노노 >> 인터넷에 있는 데이터를 가져오자

어떻게?

서버와 클라이언트 : 클라이언트가 서버에게 정보 요청하면 서버가 클라이언트한테 줌 


날씨 정보 가진 서버한테 정보 줘! 해서 받기 

1. 먼저 서버에 요청을 해보자
   - 웹 브라우저(크롬) 주소창에 주소 URL을 입력한다.
     ex) https://fakestoreapi.com/carts
     but chrome 상의 정보는 활용이 불가능
   - 서버에 정보를 요청하는 파이썬 코드를 작성한다.
     vsxode terminal 열어서 서버에 요청 보내는 도구 pip install requests 설치 후 이용

     (pip: 다른 사람이 만든 파이썬 코드 설치 도구)

     (requests: 파이썬에서 서버에 요청을 보낼 수 있는 도구)

     requests.get(url) : 해당 서버(url)에 데이터 달라고 요청하는 함수

     .json() : 내부 데이터를 json(파이썬 딕셔너리와 유사) 형태로 변환해주는 함수

     **json**
      
     api가 사용하는 데이터 형식: json java script object notation

     데이터 저장 또는 전송 시 많이 사용되는 경량의 텍스트 기반 데이터 형식! (물론 파이썬 패키지 json 도 있음. 동명이인 느낌)

     데이터는 중괄호 키 값 형태로 표현됨.

     json 형식은 문자열임. 엄연히 딕셔너리랑은 다름. json.loads()로 파이썬 딕셔너리로 변환 가능   

     
2. 서버는 어떻게 요청을 해석할까?
   - 여러 방식으로 요청을 받은 서버. 각각 어떻게 해석하지?
   - **API**
     클라이언트가 원하는 기능을 수행하기 위해 서버 측에서 만들어 놓은 프로그램. 기능: 데이터 저장, 조회, 수정, 삭제 등

     서버 측에 특정 주소로 요청이 들어오면 정해진 기능을 수행하는 API를 미리 만들어 둠. (클라이언트는 서버가 미리 만들어 놓은 주소로 요청을 보냄)

     오픈 API: 무료 개방. openweathermap api / 금융상품통합비교공시 api / 알라딘 ~~

        -주의: API KEY 발급 받아서 데이터 요청 시 함께 보냄(정상 사용자 인증), 오픈 API 사용량 제한되어 있음(공식 문서 사용량 제한 확인 필요. 요금 청구됨)


     
     
날씨 정보 제공해주는 API

OpenWeatherMapAPI


</details>






