# TIL-README-
TIL (add a README file)
---
<details><summary>SSAFY 생활</summary>

9~11 라이브 강의
11~12 개인 복습(학습 내용 나의 언어로 정리)
12~13 함께 복습
점심
14~ 복습 및 온라인 실습 git.project 

온라인 실습
문제 들어가서 my gitlab 하고 주소 복사. 내 파일 bash 열어서 git clone 컨트롤 인서트 해서 로컬에 가져옴. 
코드 작성하고 저장. 커밋 add -m 한 후에 push. 온라인 실습실 제출까지 꼭꼭


시험은 온라인 교재에서 많이 출제됨 최소 3회독 이상

</details>


<details><summary>개발 첫 걸음_ 학습 안내</summary>

# AI 시대 공부
처음 프로그래밍 배울 때 완벽을 추구하면 길을 잃기 쉽다. 
제일 중요한 것은 ``문제 해결 능력``
Ai 시대 빠른 속도 새로운 기술. 

기초 개념 정확히 잡으면서 계속해서 실습과 프로젝트로 코딩 감각을 익히는 과정을 반복해 나가야 함!!

과거처럼 모든 문법 외우고 코드를 빨리 짜는 능력? 상당 부분 AI가 대신해줄 수 있음. 

`AI라는 강력한 도구를 지휘하는 문제 해결 전문가`

경쟁력은 무엇을 만들고 싶은가? 본질적인 질문 던지는 능력.

AI에게 정확한 요구사항 전달, 결과물을 비판적으로 검증하는 능력.

이는 실습과 프로젝트를 통해 아이디어를 실현하는 과정에서 단련됨.

**코드를 통해 아이디어를 실현하고, 실용적인 결과물을 만드는 과정 을 즐기고 습관화 할 것**
AI와 협업하는 습관을 기르며 최선을 다한다면, 꾸준히 학습하고 경험을 쌓는다면, 대체 불가능한 개발자로 성장할 것.




# 학습 방법
**문제해결의 큰 그림을 그리고 핵심역량을 기르는 데 집중하자.**

어려운 개념은 개념만 이해, 인지하고 이후 심화적인 것은 필요 시 전문 도구를 사용하면 됨.

기초단계에서 메모리, 성능 최적화 얽매이지 말고 개발 경험을 쌓자.
작은 기능을 직접 완성해보는 실질적인 개발 경험이 쌓이면 성능에 대한 감각은 자연스럽게 따라옴.

AI 이용.
의도를 파악해 변수명을 다듬고 작동 이유에 대한 주석을 달며 읽기 쉬운 코드를 만들기.

디버깅 역량
코드가 원하는 대로 동작 않는 것이 개발의 진짜 시작.

AI에게 에러와 코드 보여주고 왜 발생했는지, 어떻게 해결하는지 물어보기. 구글링과 공식 문서 읽기
항상 비판적으로 검토하고 테스트하며 더 나은 방법을 생각하기.

무엇을 모르는지 파악하고 **AI에게 명확하게 질문하여 답을 얻어내는 능력**

결국엔 뭐다? 어떤 문제를 해결하고 무엇을 만들어낼 수 있는가.
각종 언어들은 이를 위한 도구.


</details>


<details><summary>2025/07/16</summary>

배운 내용:
CLI 기초문법과  martdown, git 사용법

CLI: 명령어로 사용자와 컴퓨터가 상호작용 하는 방식 command line interface

기초문법

. 현재 디렉토리
.. 상위 디렉토리
touch, mkdir, ls, cd, start, rm, pwd


CLI에서 가장 중요한 것! 경로

루트 디렉토리 / 
홈 디렉토리 ~


Markdown: 일반 텍스트로 문서를 작성하는 방법! 텍스트와 코드를 작성해 문서화.

마크다운의 여러가지 기능!

# 개발자로 성장하기
이런 거 
- 또 이런 거
**이런 것도** 되고
*이런 것* 도 되고 
---
이것도! 신기하죠?

1. 순서가
   1. 있는
        1. 리스트?

```python
print('hello')
```
이런 것도 `를 이용하여 표현 가능.쩌거 3개로 묶어주기

[이런 것도](ㅋ)
누르면 안됨
![이미지도](ㅋ) 안되긴 해
~~취소선~~
물결로 만든 취소선!

더 알고 싶은 건 마크다운 가이드로!


<details><summary>git 이용법</summary>


Git이란? 분산 버전관리 시스템

버전관리란 변화를 기록하고 추적하는 것.

git은 파일의 변경 이력을 모두 기록한다. 누가 언제 무엇을 변경했는지 알 수 있고 이전 버전으로 돌아갈 수도 있고 실수로 잘못 변경했을 때 되돌리기도 쉽다! 뭐 게임 잘못 업데이트해서 버그 생기면 과거 특정 시점의 상태를 복원할 수가 있다!!!

분산형 시스템이라 중앙 서버 없이 작업이 가능하다. 오프라인상태에서도!!
협업도!
배포와 백업에도 좋다.

---

git의 3영역

`working directory, staging area, repository`

작업디렉토리는 git 리포지토리 파일이 실제로 저장된 위치로 파일을 편집, 추가, 삭제하는 작업을 진행함. git은 이 파일들이 변경되었는지 여부를 **추적**하지만!!! 이 시점에서 Git이 그 변경을 **관리**하지는 않는다. 

변경 사항을 Git에 반영하기 위해서는?? Staging area 즉 스테이징 영역으로 이동시켜야 한다. 그것은 git add 파일명 또는 . 을 통해. 그러니까 git add는 git아 변경 사항 추가해줘~~ 하는 거임

Staging 영역은 Git 파일이 다음 커밋을 준비하는 곳! commit은 버전이라고 생각하면 됨. 스테이징 영역에 파일을 add 하면 git은 해당 파일을 추적하고 그 상태를 커밋할 준비가 된 상태로 만든다. 스테이징 영역에 추가된 파일은 커밋될 때만 실제로 버전관리가 이루어짐.

git status로 파일들의 위치 알 수 있음. 스테이징 영역에 있구나!

Repository 리포지토리 바로바로 git이 파일의 버전 이력을 관리하는 곳!!! 로컬 리포지토리는 작업 중인 프로젝트의 모든 버전과 변경 사항을 기록. git commit 명령 사용하여 파일을 스테이징 영역에서 로컬 리포지토리로 커밋하면 !! git이 변경 사항을 기록하고 새로운 버전으로 저장한다. 레포지토리에는 커밋 내역과 브랜치 정보가 포함되며 모든 변경 사항은 이곳에서 관리됨.
git commit -m "커밋 내역" 이렇게 치면 git은 변경 사항을 로컬 리포지토리에 저장하고 버전 히스토리에 기록한다. git log로 확인


예시 워크플로우

작업 디렉토리에서 파일을 수정한다. >> git add 파일명 으로 변경사항을 스테이징 영역에 추가하고 >> git commit -m "커밋명" 으로 레포지토리에 커밋하고! >> 리포지토리에 변경 사항을 원격 서버로 푸시하려면 git push origin main !! 
</details>


</details>


<details><summary>2025/07/17</summary>
   오늘 배운 것

Git 로컬과 원격 저장소 왔다갔다 

github 쓰는 방법

나 지금 수정하고 있잖아~~!!
저장을 안해서였다...
commit 수정 방법??

---
</details>

<details><summary> 2025/07/21 </summary>

**프로그래밍의 의미와 Python 소개 및 Data type 특징**

## 프로그래밍
프로그램: 어떤 문제를 해결하기 위한 명령어 집합 
프로그래밍의 핵심은 새 연산을 정의하고 조합해 유용한 작업을 수행하는 것!


파이썬?! 타언어에 비해 쉽고 간결한 문법
풍부한 커뮤니티와 광범위한 응용 분야(웹 개발, 데이터분석, 인공지능 등)


왜 ai와 머신러닝 개발에 파이썬을 쓸까?
여러 라이브러리 도구들이 모두 파이썬으로 제공됨.(왜? 그냥 첨 만든 사람이 파이썬으로 했나?)

파이썬 인터프리터가 사용자의 명령을 기계어로 바꿔줌

파이썬 인터프리터 사용법? 
- shell
터미널에서 python -i 
근데 이렇게 잘 안 함.
- samply.py 파이썬 만들어 파이썬 프로그램 실행

- 표현식
하나의 값으로 평가될 수 있는 코드
표현식 예시 : 3+5, x>10
- 값 
표현식이 평가된 결과
값 예시 : 8, True


- 변수와 메모리
=으로 변수에 값을 할당함.(재사용하려고 변수 사용)
변수 알파벳, _, 숫자로 구성. 숫자로 시작 불가. 대소문자 구분. True같은 예약어로는 변수 이용 불가능.

메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재한다.(메모리주소: 컴퓨터가 특정 데이터값 정확히 찾기 위해 사용하는 기계적 숫자 주소)

`객체`
고유한 ID(메모리주소)
타입
값
위 3 개 정보를 묶은 것을 객체 pbject라 부름.

변수는 특정 객체를 가리키는 이름표. 
변수는 메모리주소를 가지지 않는다.참조할 뿐
변수는 한 마디로 '객체를 가리키는 이름'


할당문 

- 할당문 동작 순서
오른쪽 표현식 평가. 계산하여 하나의 결과값(객체)를 만듦. > 왼쪽 변수명 확인. 새로운 이름표 만들거니 기존 거 이용 > 변수명과 결과값 연결. 이전에 다른 객체 가리키고 있었다면 그 연결 끊어지고 새로운 객체와의 연결만 남음 재할당



|용어|핵심 정의|비유(주소록)|
|---------|------|------|
|객체 object|데이터(값 타입 행동)의 실체|'김철수'라는 실제 사람|
|메모리 주소|객체가 저장된 고유한 위치|김철수의 실제 집 주소|
|변수 variable|객체를 가리키는 이름표|주소록에 저장된 '내친구 김철수'라는 이름|



<details><summary>데이터 타입</summary>

중요한 이유: 값의 종류와 그 값으로 할 수 있는 연산을 결정하기 때문. 즉, 타입마다 가능한 기능과 연산이 다름.

정수 int 
실수 float 소수점까지. 
지수표현법 1,230,000,000은 1.23 * 10^9 인데 이걸 1.23e9라고 표현함.
0.00314는 3.14 * 10^-3 이라서 3.14e-3이라 씀 e E 상관없음.


숫자형 타입의 행동은 산술 연산!

연산자 우선순위는 동일. () 사용 가능.

시퀀스 타입: 여러 데이터가 정해진 `순서`대로 일렬로 `나열`된 자료 구조 
대표 시퀀스 타입: str, list, tuple, range


index: 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호 (0번부터)

시퀀스타입 여러가지인데 공통 특징 있음.
순서/인덱싱/슬라이싱/길이/반복


시퀀스 타입 중 문자열str
```python

my_data = 'Hello'

my_data[1] = 'e'
my_data[1:4] = 'ell'


```

문자열 str : 문자들 `순서` 있고 `변경 불가능`한 시퀀스 자료형

`escape sequence`
\이용
\n 줄바꿈 \t 탭 (띄우기) \\ 백슬래시 하나 \' 작은 따옴표 \" 큰 따옴표

여러 줄 작성 시 ''' 또는 """ 이용


`f-string` 아주 중요!

문자열 내에 변수나 표현식의 결과를 쉽게 삽입하는 방법.
문자열 시작 전에 f 붙이고 삽입할 부분을 {} 로 감싸줌. 

```python
name= '홍길동'
age=25

greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'

```
f-string 다양한 기능 있음. 심화 사용법 알아보기

index: 시퀀스 자료형 각 값의 위치를 식별하기 위해 부여된 고유 번호. 0부터 시작 왜? 거리 개념임. 시작점으로부터 떨어진 거리. 
음수 인덱스 지원. -1은 맨 마지막 값. 

slicing: 시퀀스 일부분 잘라내어 `새로운 시퀀스 생성`
슬라이싱 사용법 대괄호 [] 안에 시작 위치, 끝 위치, 간격 을 콜론:으로 구분하여 지정
my_sequence[start:stop:step]

start 시작인덱스(포함)
stop 끝 인덱스(포함x)
step 건너뛰는 간격 
상황따라 생략 가능


my_str[2:4] 하면 2,3 자리 나오고 4는 포함 안됨.

왜 끝에 값은 빠질까???
시작 값은 0 n번 반복 시 실제로 마지막 시행은 n-1번째가 됨. 즉, 3번 반복 시 0,1,2 가 시행됨. 그래서 마지막 수 앞에서 멈춤.
너무 헷갈린다면 문자열 사이를  index로 생각.


여러가지 해보니까 my_str[7]처럼 아예 벗어난 인덱스 주면 error 뜨는데 [7:9] 나 [9:7] 같은 거 넣으면 error 안 뜨고 그냥 값이 안 나옴. [::-1] 은 역순


`문자열의 불변성`
my_str[1] = 'a' 와 같이 할당하려하면 error
type error 'str' object does not support item assignment 

변경은 불가능. 재할당하거나 새로운 문자열을 생성하는 수밖에


<details><summary>참고</summary>

진법 표현 prefix

2진수 print(0b10)
8진수 print(0o30)
16wlstn print(0x10)



실수의 함정, 부동소수점 오차
result = 0.1 + 0.2 
print(result == 0.3) False
print(result) 0.300000000004
왜?
컴퓨터의 실수 처리 방식.
부동소수점(반올림)오차
컴퓨터는 2진법을 사용. 무한 소수의 발생과 근삿값 저장.10진수 소수 중 일부 2진수로 바꾸면 무한 소수 됨. 메모리 유한하므로 근삿값으로 잘라서 저장함. 근사치로 인해 오차 발생.
> 해결책

decimal 모듈 사용해 부동소수점 연산의 정확성을 보장 
실수를 2진수로 변환하지 않고 10진수 자체로 정확하게 연산할 수 있게 해줌.
소수 계산할 때 조심하기


표현식과 문장

할당문 조건문 반복문 statement 특정 동작을 지시하는 실행 가능 코드 최소단위. 문장은 완결된 하나의 명령 

구분: 코드 실행 시 하나의 값이 남는다면 표현식, 안 남는다면 문장. 
10+20 : 표현식
name = '홍길동' : 문장


Style Guide 코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들
대표적으로 PEP 8

직관적인 이름, 공백 스페이스 4칸 or Tab
한 줄 길이 79자, 길면 줄 바꿈 
문자와 밑줄로 작성, 함수 정의 클래스 정의 등 블록 사이에는 빈 줄을 추가

age=10 말고 age = 10

주석:
샾 사용 또는 묶어서 한 방에 컨트롤 슬래쉬

복잡한 코드 python tutor 코드 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구





터미널에 ls 쳐서 내가 실행하고 싶은 파이썬 파일이 존재하는지 확인하고 실행하기
python 파일이름 하면 내가 원하는 파이썬 파일 실행됨.

할당문 
num = 10
double = 2 * num
print(double)
20이 출력.
num = 5
print(double)
여전히 20

double에 2*10 값을 저장한 것,
값이 저장되는 것이지 표현식을 저장하는 것이 아님.
좀 중요함 헷갈리는 부분. double에 20이 저장되는 것이지 2*num 이 저장되는 것이 아니다잉


16진수
0부터 9까지 이용 후 a부터 f까지 감 우왕~~굉장히 10진법적인 사고


</details>

