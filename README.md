# TIL-README-
TIL (add a README file)
---
<details><summary>SSAFY 생활</summary>

9~11 라이브 강의
11~12 개인 복습(학습 내용 나의 언어로 정리)
12~13 함께 복습
점심
14~ 복습 및 온라인 실습 git.project 

온라인 실습
문제 들어가서 my gitlab 하고 주소 복사. 내 파일 bash 열어서 git clone 컨트롤 인서트 해서 로컬에 가져옴. 
코드 작성하고 저장. 커밋 add -m 한 후에 push. 온라인 실습실 제출까지 꼭꼭


시험은 온라인 교재에서 많이 출제됨 최소 3회독 이상

</details>


<details><summary>개발 첫 걸음_ 학습 안내</summary>

# AI 시대 공부
처음 프로그래밍 배울 때 완벽을 추구하면 길을 잃기 쉽다. 
제일 중요한 것은 ``문제 해결 능력``
Ai 시대 빠른 속도 새로운 기술. 

기초 개념 정확히 잡으면서 계속해서 실습과 프로젝트로 코딩 감각을 익히는 과정을 반복해 나가야 함!!

과거처럼 모든 문법 외우고 코드를 빨리 짜는 능력? 상당 부분 AI가 대신해줄 수 있음. 

`AI라는 강력한 도구를 지휘하는 문제 해결 전문가`

경쟁력은 무엇을 만들고 싶은가? 본질적인 질문 던지는 능력.

AI에게 정확한 요구사항 전달, 결과물을 비판적으로 검증하는 능력.

이는 실습과 프로젝트를 통해 아이디어를 실현하는 과정에서 단련됨.

**코드를 통해 아이디어를 실현하고, 실용적인 결과물을 만드는 과정 을 즐기고 습관화 할 것**
AI와 협업하는 습관을 기르며 최선을 다한다면, 꾸준히 학습하고 경험을 쌓는다면, 대체 불가능한 개발자로 성장할 것.




# 학습 방법
**문제해결의 큰 그림을 그리고 핵심역량을 기르는 데 집중하자.**

어려운 개념은 개념만 이해, 인지하고 이후 심화적인 것은 필요 시 전문 도구를 사용하면 됨.

기초단계에서 메모리, 성능 최적화 얽매이지 말고 개발 경험을 쌓자.
작은 기능을 직접 완성해보는 실질적인 개발 경험이 쌓이면 성능에 대한 감각은 자연스럽게 따라옴.

AI 이용.
의도를 파악해 변수명을 다듬고 작동 이유에 대한 주석을 달며 읽기 쉬운 코드를 만들기.

디버깅 역량
코드가 원하는 대로 동작 않는 것이 개발의 진짜 시작.

AI에게 에러와 코드 보여주고 왜 발생했는지, 어떻게 해결하는지 물어보기. 구글링과 공식 문서 읽기
항상 비판적으로 검토하고 테스트하며 더 나은 방법을 생각하기.

무엇을 모르는지 파악하고 **AI에게 명확하게 질문하여 답을 얻어내는 능력**

결국엔 뭐다? 어떤 문제를 해결하고 무엇을 만들어낼 수 있는가.
각종 언어들은 이를 위한 도구.


</details>


<details><summary>2025/07/16</summary>

배운 내용:
CLI 기초문법과  martdown, git 사용법

CLI: 명령어로 사용자와 컴퓨터가 상호작용 하는 방식 command line interface

기초문법

. 현재 디렉토리
.. 상위 디렉토리
touch, mkdir, ls, cd, start, rm, pwd


CLI에서 가장 중요한 것! 경로

루트 디렉토리 / 
홈 디렉토리 ~


Markdown: 일반 텍스트로 문서를 작성하는 방법! 텍스트와 코드를 작성해 문서화.

마크다운의 여러가지 기능!

# 개발자로 성장하기
이런 거 
- 또 이런 거
**이런 것도** 되고
*이런 것* 도 되고 
---
이것도! 신기하죠?

1. 순서가
   1. 있는
        1. 리스트?

```python
print('hello')
```
이런 것도 `를 이용하여 표현 가능.쩌거 3개로 묶어주기

[이런 것도](ㅋ)
누르면 안됨
![이미지도](ㅋ) 안되긴 해
~~취소선~~
물결로 만든 취소선!

더 알고 싶은 건 마크다운 가이드로!


<details><summary>git 이용법</summary>


Git이란? 분산 버전관리 시스템

버전관리란 변화를 기록하고 추적하는 것.

git은 파일의 변경 이력을 모두 기록한다. 누가 언제 무엇을 변경했는지 알 수 있고 이전 버전으로 돌아갈 수도 있고 실수로 잘못 변경했을 때 되돌리기도 쉽다! 뭐 게임 잘못 업데이트해서 버그 생기면 과거 특정 시점의 상태를 복원할 수가 있다!!!

분산형 시스템이라 중앙 서버 없이 작업이 가능하다. 오프라인상태에서도!!
협업도!
배포와 백업에도 좋다.

---

git의 3영역

`working directory, staging area, repository`

작업디렉토리는 git 리포지토리 파일이 실제로 저장된 위치로 파일을 편집, 추가, 삭제하는 작업을 진행함. git은 이 파일들이 변경되었는지 여부를 **추적**하지만!!! 이 시점에서 Git이 그 변경을 **관리**하지는 않는다. 

변경 사항을 Git에 반영하기 위해서는?? Staging area 즉 스테이징 영역으로 이동시켜야 한다. 그것은 git add 파일명 또는 . 을 통해. 그러니까 git add는 git아 변경 사항 추가해줘~~ 하는 거임

Staging 영역은 Git 파일이 다음 커밋을 준비하는 곳! commit은 버전이라고 생각하면 됨. 스테이징 영역에 파일을 add 하면 git은 해당 파일을 추적하고 그 상태를 커밋할 준비가 된 상태로 만든다. 스테이징 영역에 추가된 파일은 커밋될 때만 실제로 버전관리가 이루어짐.

git status로 파일들의 위치 알 수 있음. 스테이징 영역에 있구나!

Repository 리포지토리 바로바로 git이 파일의 버전 이력을 관리하는 곳!!! 로컬 리포지토리는 작업 중인 프로젝트의 모든 버전과 변경 사항을 기록. git commit 명령 사용하여 파일을 스테이징 영역에서 로컬 리포지토리로 커밋하면 !! git이 변경 사항을 기록하고 새로운 버전으로 저장한다. 레포지토리에는 커밋 내역과 브랜치 정보가 포함되며 모든 변경 사항은 이곳에서 관리됨.
git commit -m "커밋 내역" 이렇게 치면 git은 변경 사항을 로컬 리포지토리에 저장하고 버전 히스토리에 기록한다. git log로 확인


예시 워크플로우

작업 디렉토리에서 파일을 수정한다. >> git add 파일명 으로 변경사항을 스테이징 영역에 추가하고 >> git commit -m "커밋명" 으로 레포지토리에 커밋하고! >> 리포지토리에 변경 사항을 원격 서버로 푸시하려면 git push origin main !! 
</details>


</details>


<details><summary>2025/07/17</summary>
   오늘 배운 것

Git 로컬과 원격 저장소 왔다갔다 

github 쓰는 방법

나 지금 수정하고 있잖아~~!!
저장을 안해서였다...
commit 수정 방법??

---
</details>

<details><summary> 2025/07/21 </summary>

**프로그래밍의 의미와 Python 소개 및 Data type 특징**

## 프로그래밍
프로그램: 어떤 문제를 해결하기 위한 명령어 집합 
프로그래밍의 핵심은 새 연산을 정의하고 조합해 유용한 작업을 수행하는 것!


파이썬?! 타언어에 비해 쉽고 간결한 문법
풍부한 커뮤니티와 광범위한 응용 분야(웹 개발, 데이터분석, 인공지능 등)


왜 ai와 머신러닝 개발에 파이썬을 쓸까?
여러 라이브러리 도구들이 모두 파이썬으로 제공됨.(왜? 그냥 첨 만든 사람이 파이썬으로 했나?)

파이썬 인터프리터가 사용자의 명령을 기계어로 바꿔줌

파이썬 인터프리터 사용법? 
- shell
터미널에서 python -i 
근데 이렇게 잘 안 함.
- samply.py 파이썬 만들어 파이썬 프로그램 실행

- 표현식
하나의 값으로 평가될 수 있는 코드
표현식 예시 : 3+5, x>10
- 값 
표현식이 평가된 결과
값 예시 : 8, True


- 변수와 메모리
=으로 변수에 값을 할당함.(재사용하려고 변수 사용)
변수 알파벳, _, 숫자로 구성. 숫자로 시작 불가. 대소문자 구분. True같은 예약어로는 변수 이용 불가능.

메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재한다.(메모리주소: 컴퓨터가 특정 데이터값 정확히 찾기 위해 사용하는 기계적 숫자 주소)

`객체`
고유한 ID(메모리주소)
타입
값
위 3 개 정보를 묶은 것을 객체 pbject라 부름.

변수는 특정 객체를 가리키는 이름표. 
변수는 메모리주소를 가지지 않는다.참조할 뿐
변수는 한 마디로 '객체를 가리키는 이름'


할당문 

- 할당문 동작 순서
오른쪽 표현식 평가. 계산하여 하나의 결과값(객체)를 만듦. > 왼쪽 변수명 확인. 새로운 이름표 만들거니 기존 거 이용 > 변수명과 결과값 연결. 이전에 다른 객체 가리키고 있었다면 그 연결 끊어지고 새로운 객체와의 연결만 남음 재할당



|용어|핵심 정의|비유(주소록)|
|---------|------|------|
|객체 object|데이터(값 타입 행동)의 실체|'김철수'라는 실제 사람|
|메모리 주소|객체가 저장된 고유한 위치|김철수의 실제 집 주소|
|변수 variable|객체를 가리키는 이름표|주소록에 저장된 '내친구 김철수'라는 이름|



<details><summary>데이터 타입</summary>

중요한 이유: 값의 종류와 그 값으로 할 수 있는 연산을 결정하기 때문. 즉, 타입마다 가능한 기능과 연산이 다름.

정수 int 
실수 float 소수점까지. 
지수표현법 1,230,000,000은 1.23 * 10^9 인데 이걸 1.23e9라고 표현함.
0.00314는 3.14 * 10^-3 이라서 3.14e-3이라 씀 e E 상관없음.


숫자형 타입의 행동은 산술 연산!

연산자 우선순위는 동일. () 사용 가능.

시퀀스 타입: 여러 데이터가 정해진 `순서`대로 일렬로 `나열`된 자료 구조 
대표 시퀀스 타입: str, list, tuple, range


index: 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호 (0번부터)

시퀀스타입 여러가지인데 공통 특징 있음.
순서/인덱싱/슬라이싱/길이/반복


시퀀스 타입 중 문자열str
```python

my_data = 'Hello'

my_data[1] = 'e'
my_data[1:4] = 'ell'


```

문자열 str : 문자들 `순서` 있고 `변경 불가능`한 시퀀스 자료형

`escape sequence`
\이용
\n 줄바꿈 \t 탭 (띄우기) \\ 백슬래시 하나 \' 작은 따옴표 \" 큰 따옴표

여러 줄 작성 시 ''' 또는 """ 이용


`f-string` 아주 중요!

문자열 내에 변수나 표현식의 결과를 쉽게 삽입하는 방법.
문자열 시작 전에 f 붙이고 삽입할 부분을 {} 로 감싸줌. 

```python
name= '홍길동'
age=25

greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'

```
f-string 다양한 기능 있음. 심화 사용법 알아보기

index: 시퀀스 자료형 각 값의 위치를 식별하기 위해 부여된 고유 번호. 0부터 시작 왜? 거리 개념임. 시작점으로부터 떨어진 거리. 
음수 인덱스 지원. -1은 맨 마지막 값. 

slicing: 시퀀스 일부분 잘라내어 `새로운 시퀀스 생성`
슬라이싱 사용법 대괄호 [] 안에 시작 위치, 끝 위치, 간격 을 콜론:으로 구분하여 지정
my_sequence[start:stop:step]

start 시작인덱스(포함)
stop 끝 인덱스(포함x)
step 건너뛰는 간격 
상황따라 생략 가능


my_str[2:4] 하면 2,3 자리 나오고 4는 포함 안됨.

왜 끝에 값은 빠질까???
시작 값은 0 n번 반복 시 실제로 마지막 시행은 n-1번째가 됨. 즉, 3번 반복 시 0,1,2 가 시행됨. 그래서 마지막 수 앞에서 멈춤.
너무 헷갈린다면 문자열 사이를  index로 생각.


여러가지 해보니까 my_str[7]처럼 아예 벗어난 인덱스 주면 error 뜨는데 [7:9] 나 [9:7] 같은 거 넣으면 error 안 뜨고 그냥 값이 안 나옴. [::-1] 은 역순


`문자열의 불변성`
my_str[1] = 'a' 와 같이 할당하려하면 error
type error 'str' object does not support item assignment 

변경은 불가능. 재할당하거나 새로운 문자열을 생성하는 수밖에


<details><summary>참고</summary>

진법 표현 prefix

2진수 print(0b10)
8진수 print(0o30)
16wlstn print(0x10)



실수의 함정, 부동소수점 오차
result = 0.1 + 0.2 
print(result == 0.3) False
print(result) 0.300000000004
왜?
컴퓨터의 실수 처리 방식.
부동소수점(반올림)오차
컴퓨터는 2진법을 사용. 무한 소수의 발생과 근삿값 저장.10진수 소수 중 일부 2진수로 바꾸면 무한 소수 됨. 메모리 유한하므로 근삿값으로 잘라서 저장함. 근사치로 인해 오차 발생.
> 해결책

decimal 모듈 사용해 부동소수점 연산의 정확성을 보장 
실수를 2진수로 변환하지 않고 10진수 자체로 정확하게 연산할 수 있게 해줌.
소수 계산할 때 조심하기


표현식과 문장

할당문 조건문 반복문 statement 특정 동작을 지시하는 실행 가능 코드 최소단위. 문장은 완결된 하나의 명령 

구분: 코드 실행 시 하나의 값이 남는다면 표현식, 안 남는다면 문장. 
10+20 : 표현식
name = '홍길동' : 문장


Style Guide 코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들
대표적으로 PEP 8

직관적인 이름, 공백 스페이스 4칸 or Tab
한 줄 길이 79자, 길면 줄 바꿈 
문자와 밑줄로 작성, 함수 정의 클래스 정의 등 블록 사이에는 빈 줄을 추가

age=10 말고 age = 10

주석:
샾 사용 또는 묶어서 한 방에 컨트롤 슬래쉬

복잡한 코드 python tutor 코드 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구





터미널에 ls 쳐서 내가 실행하고 싶은 파이썬 파일이 존재하는지 확인하고 실행하기
python 파일이름 하면 내가 원하는 파이썬 파일 실행됨.

할당문 
num = 10
double = 2 * num
print(double)
20이 출력.
num = 5
print(double)
여전히 20

double에 2*10 값을 저장한 것,
값이 저장되는 것이지 표현식을 저장하는 것이 아님.
좀 중요함 헷갈리는 부분. double에 20이 저장되는 것이지 2*num 이 저장되는 것이 아니다잉


16진수
0부터 9까지 이용 후 a부터 f까지 감 우왕~~굉장히 10진법적인 사고


</details>
</details>
</details>


<details><summary>2025/7/22</summary>

# 컬렉션과 연산자

**컬렉션(list, tuple, range, dict, set)과 분류(가변성, 순서)**
**Other Types(None과 Boolean)**
**형변환(암시적, 명시적)**
**연산자**

다양한 데이터 구조와 연산자를 활용하여 장바구니를 직접 만들고 관리할 수 있다.


복습: 시퀀스 자료형 시퀀스의 특징
시퀀스 자료형이란, 여러 개의 값을 `순서`대로 저장하고 각 요소를 `인덱스`를 통해 접근할 수 있는 자료형.
str, list, tuple이 있음. (dict와 set은 시퀀스 자료형 아님. 순서 없고 인덱스로 접근 불가)

특징 5가지: 순서 있음, 인덱싱 가능 a[2], 슬라이싱 가능 a[1:3], 반복 가능, 길이 확인 가능

(추가: 문자열뿐만 아니라 정수형, 실수형 등도 불변. a = 10 에서 0을 1로 인덱싱해서 바꾸는 것 불가능. 재할당하는 수밖에)


리스트
---
- 여러 개의 값을 순서대로 저장하는,`변경 가능한``시퀀스 자료형` mutable
- 시퀀스이므로 인덱싱 슬라이싱 길이 모두 가
- 대괄호[] 안에 값들을 쉼표 , 로 구분
- 숫자 문자열 다른 리스트까지 모든 종류 데이터 담을 수 있다.
- 값을 추가 수정 삭제 등 자유롭게 변경 가능 
- 중첩 리스트 my_list[4][2][3] 

가변성: 생성된 후 그 내용을 변경할 수 있는 성질.
변경: 수정 추가 삭제 
문자열의 불변성과 정반대되는 중요한 특징.

인덱싱으로 값 수정하기
슬라이싱으로 여러 값 한번에 바꾸기
my_list = [1,2,3,4,5]
my_list[2:4] = ['three', 'four']
print(my_list) [1,2,'three,'four',5]
list는 가장 많이 활용하게 될 data type 중 하나

[2:4]로 하면 2,3  요소 없어지고 그 자리에 들어가는 새로운 요소 개수 제한 없음.


튜플
---
- 여러 개의 값을 `순서`대로 저장, `변경 불가능`한 시퀀스 자료형
- 소괄호() 이용, 쉼표 , 로 구분
- 리스트처럼 모든 종류 데이터 담을 수 있음
- 리스트와 유사하나, 한 번 만들어지면 수정 불가능. `불변성`
- 시퀀스처럼 인덱싱, 슬라이싱, 길이 확인, 반복 이용 가능   
  특징
  - 요소가 하나일 때 쉼표 , 이용 my_tuple = (1, ) trailing comma 후행쉼표라고 함. 
  - 소괄호 없이 만들 수 있음. my_tuple = 1, 'hello', 3.14


튜플은 언제 쓰냐?
튜플이 불변 자료형인 이유는?
튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용.
다중 할당, 값 교환, 함수 다중 반환 등
개발자가 직접적으로 사용하기보다는 내부적으로 처리될 때 사용됨

튜플은 데이터의 안정성과 무결성을 보장하기 때문에 리스트와 구별됨. 내부동작에서 사용
실제 문제 풀 때 쓰는 경우 거의 없음.

```python
#다중할당
x, y = 10, 20
#실제 내부 동작
(x, y) = (10, 20)

#값 교환
x, y = 1, 2
x, y = y, x

#실제 내부 동작
temp = (y, x) # 튜플 생성
x, y = temp # 튜플 풀어냄
print(x, y) # 2 1

```


range
---
`연속된 정수 시퀀스` `생성`하는 `변경 불가능`한 자료형

(변경 가능한 자료형은 아직 리스트밖에 없노! 문자열, 튜플, range 다 불변)
- range는 주로 반복문에서 사용
- range() 는 1,2,3 개까지의 매개변수를 가질 수 있음.
  - range(stop)
  - range(start, stop)
  - range(start, stop, step)

```python
# 매개변수 하나일 때. stop으로 인식. start는 0, step은 1이 기본값으로 설정
my_range_1 = range(5)

print(my_range_1) # range(0, 5)

print(list(my_range_1)) # [0, 1, 2, 3, 4] 리스트로 형 변

# 매개변수 두 개
my_range_2 = range(1,10)

# 매개변수 세 개
my_range_3 = range(5, 0, -1)

print(list(my_range_3)) # [5, 4, 3, 2, 1]


```
- range에서 모든 숫자 메모리 저장하는 게 아니라 시작, 끝, 간격이라는 규칙만 기억하여 메모리 효율적
- range는 list로 형 변환 시 내부 값을 확인 가능. 실제 사용할 때는 형 변환하지 않고 반복문에 사용

```python
for i in range(1,10,2):
   print(i)   # 1, 3, 5, 7, 9
```

step 규칙
step은 시퀀스의 간격과 방향을 결정
error가 나지는 않음. step의 부호에 따라 start와 stop의 대소관계 생각.



dict
---
오늘의 수업 중 젤 중요한 것 두 가지 꼽으라면 list와 dict

**딕셔너리: key와 value 쌍으로 이루어진, 순서와 중복이 없는 변경 가능한 자료형.(비시퀀스)**

순서가 없다?! >> 인덱스가 없다.
인덱스 없이 어떻게 접근해? >> key로 접근!

- 중괄호 {} 이용. 쉼표, 로 구분
- my_dict = {'key': 'value'} # 한 쌍
  
- key: 값을 식별하기 위한 고유한 이름표. 중복 불가(순서가 없는 대신 고유한 키로 구분).
  변경 불가능한 자료형만 사용 가능. (str, int, float, tuple 가능, list, dict 불가능)
  
- value: 키에 해당하는 실제 데이터. '문자열', 12, [l, i, s, t] 모두 가능

- key로 value 찾기 가능, 역은 불가능. key는 고유하지만. value는 여러 번 나와도 됨.

- key가 두 번 이상 나온다면? 뒤에 나온 것 기준으로 하나만 나옴.

dict = {'apple': 500, 'apple': 300} 
print(dict['apple']) # 300


순서가 없는 자료형. 비시퀀스. key를 통해 접근

print(my_dict_1[key]) 하면 value가 나옴, 존재하지 않는 key 쓰면 error

딕셔너리 언제 이용하냐?

데이터에 순서 필요 없고 데이터에 key 붙여 관리하고 싶을때 이용. 인적 정보나 캐릭터 능력치 


set
---
`순서와 중복이 없는` `변경 가능`한 자료형. 비시퀀스(인덱싱, 슬라이싱 사용 불가. 근데 len은 사용 가능.)


- 중괄호{} 이용, 쉼표 , 로 구분.
- 딕셔너리도 중괄호 {} 이용! >> 공집합은 {}로 표현 못함. 딕셔너리니까
- my_set_1 = set() 라고 표현함. my_set_2 = {1, 1, 2} #print(my_set_2) {1, 2}
- 원소 동일하면 하나만 나옴.(중복 불가) 순서 없으므로 인덱싱 불가
- 합집합 | (shift 백슬래쉬), 차집합 -, 교집합 &
- 중복 제거하고 싶을 때 사용 가능
- 잘 사용 안하긴 함. 특수 상황에서 사용

Other types
---
None: 값이 없음을 표현하는 특별한 데이터 타입. 숫자 0이나 빈 문자열 '' 과는 다름!! 값이 존재하지 않음, 아직 정해지지 않음 이라는 상태를 나타냄.
대소문자 주의. None 이다.

Boolean: 참과 거짓 두 가지 값만 가지는 데이터 타입. 프로그램의 흐름을 제어하는 조건문에서 True와 False를 판단
주로 조건 반복문과 함께 사용됨.
비교 논리 연산의 평가 결과



Collection
---
여러 개의 값을 하나로 묶어 관리하는 자료형들을 `통칭`하는 말
str, list, tuple, range, set, dict 데이터 타입 모두 Collection에 분류.

|컬렉션명 | 변경 가능 여부(가변성, 불변성) | 순서 존재 여부(인덱싱 가능 여부)|
|---|---|---|
|str |X|O|
|list|O|O|
|tuple|X|O|
|dict|O|X|
|set|O|X|



형변환
---
한 데이터 타입을 다른 데이터 타입으로 변환하는 과정.


암시적 형변환과 명시적 형변환

암시적 형변환: 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
ex) print(3 + 5.0) # 8.0
   print(True + 3) # 4
   print(True + False) # 1

명시적 형변환: 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것.
서로 다른 타입의 데이터를 호환되도록 맞추는 과정.
해외에서 어댑터 끼우는 느낌. 

int("123") 결과 123
str(100) 결과 "100"
list("abc") 결과 ['a', 'b', 'c']
set([1, 2, 2]) 결과 {1,2}

항상 되는가?

str -> int 형식에 맞는 숫자만 가능

print(int('1')) # 1 '1' 문자열을 정수로 형 변환.

print(int('3.5')) # '3.5'는 실수형태의 문자열이므로 error 뜸.

print(float('3.5')) # 3.5 '3.5'라는 문자열을 실수로 형 변환.

print(int(1.9)) # 1 실수를 정수형으로 형 변환.

int -> str 모두 가능

print(str(2) + '등') # 2등

그 무엇도 range와 dict으로 형 변환 불가능함.


연산자
---
산술연산자, 복합연산자, 비교연산자, 논리연산자, 단축 평가, 멤버십연산자, 시퀀스형 연산자 그리 연산자 우선순위


복합연산자: 연산과 할당이 함께 이뤄짐.

+= -= *= /= //= %= **=  알 것 같기도~  x **= 3 : x에 x의 3승을 할당해라

비교 연산자

ㅡ=, ==, !=, is, is not


단축 평가

똑똑한 게으름?!: 결과가 정해졌다면 뒤에 코드까지 확인하지 않음. 이렇게 결과가 확정되는 순간 평가를 '단축'하고 넘어간다고 해서 '단축 평가' 라고 부름.

논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

참과 거짓에 대한 새


멤버십 연산자: in, not in 
print('h' in word)  
왼쪽이 요소 오른쪽이 컬렉
결과값: True, False


시퀀스형 연산자: + *
+ * 가 시퀀스자료형(문자열, 리스트, 튜플)에서 결합, 반복 연산자로 쓰임.


trailing comma(후행 쉼표)
컬렉션의 마지막 요소 뒤에 붙는 쉼표
앞에 하나의 요소로 구성된 튜플에서 필수였음. tuple = (1,)
그 외에는 `선택 사항`

딕셔너리에서 잘 사용됨. 가독성 측면에서

```python
item = [
   'item1',
   'item2',
   'item3',
]

config = {
   'host': 'localhost',
   'port': 8080,
   'debug': True,
}


```

각 요소 별도 줄에 작성. 마지막 요소 뒤에 trailing comma 추가, 닫는 괄호는 새로운 줄에 배치.
그냥 한 로 쭉 쓸 때는 trailing comma 쓰지 않음.

`문제 풀이
리스트 [1:4]면 그 앞에까지 
딕셔너리는 {'키': '값'}
역순[::-1]
set는 순서 없고, 중복 허용하지 않음
딕셔너리는 value 바꿀 수 있음.

</details>

